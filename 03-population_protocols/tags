!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/45968eff/
Agent	src/protocol.cc	/^Agent::Agent (state_t state)$/;"	f	class:Agent
Agent	src/protocol.hh	/^Agent {$/;"	c
Algorytmy iteracyjne	report/report.tex	/^\\subsubsection{Algorytmy iteracyjne}$/;"	b	subsection:Analiza wyników i wydajność zaimplementowanych algorytmów""Analiza wyników
Analiza wyników	report/report.tex	/^\\subsection{Analiza wyników}$/;"	u	section:Analiza wyników i wydajność zaimplementowanych algorytmów
Analiza wyników i wydajność zaimplementowanych algorytmów	report/report.tex	/^\\section{Analiza wyników i wydajność zaimplementowanych algorytmów}$/;"	s
CC	Makefile	/^CC=g++$/;"	m
CC	src/Makefile	/^CC=g++$/;"	m
Gauss oraz Gauss z optymalizacją dla macierzy rzadkich	report/report.tex	/^\\subsubsection{Gauss oraz Gauss z optymalizacją dla macierzy rzadkich}$/;"	b	subsection:Analiza wyników i wydajność zaimplementowanych algorytmów""Analiza wyników
Generator	src/generator.hh	/^Generator {$/;"	c
Generowanie układu równań dla danej liczby agentów	report/report.tex	/^\\subsection{Generowanie układu równań dla danej liczby agentów}$/;"	u	section:Implementacja i możliwość stosowania metod iteracyjnych
Implementacja i możliwość stosowania metod iteracyjnych	report/report.tex	/^\\section{Implementacja i możliwość stosowania metod iteracyjnych}$/;"	s
LDFLAGS	Makefile	/^LDFLAGS=-pthread$/;"	m
LDFLAGS	src/Makefile	/^LDFLAGS=-pthread$/;"	m
MAX_AGENTS_COUNT	src/main.cc	/^#define  MAX_AGENTS_COUNT /;"	d	file:
Majority/Consensus problem	report/report.tex	/^\\section{Majority\/Consensus problem}$/;"	s
Metody PG oraz PGS	report/report.tex	/^\\subsubsection{Metody PG oraz PGS}$/;"	b	subsection:Analiza wyników i wydajność zaimplementowanych algorytmów""Wydajność
Metody iteracyjne	report/report.tex	/^\\subsubsection{Metody iteracyjne}$/;"	b	subsection:Analiza wyników i wydajność zaimplementowanych algorytmów""Wydajność
Metody iteracyjne a problem	report/report.tex	/^\\subsection{Metody iteracyjne a problem}$/;"	u	section:Implementacja i możliwość stosowania metod iteracyjnych
MonteCarlo	src/protocol.cc	/^MonteCarlo::MonteCarlo (int iterations)$/;"	f	class:MonteCarlo
MonteCarlo	src/protocol.hh	/^MonteCarlo {$/;"	c
MyMatrix	src/matrix.hh	/^    MyMatrix (int width)$/;"	f	class:MyMatrix
MyMatrix	src/matrix.hh	/^class MyMatrix {$/;"	c
NO	src/protocol.hh	/^  NO,       \/\/ 0: keeps the boolean logic correct$/;"	e	enum:state
O implementacji	report/report.tex	/^\\subsection{O implementacji}$/;"	u	section:Operacje na macierzach
OUTNAME	Makefile	/^OUTNAME=protocols$/;"	m
Operacje na macierzach	report/report.tex	/^\\section {Operacje na macierzach}$/;"	s
PROGRESSBAR_STRING	src/util.hh	/^#define PROGRESSBAR_STRING /;"	d
PROGRESSBAR_WIDTH	src/util.hh	/^#define PROGRESSBAR_WIDTH /;"	d
PROTOCOLS_GENERATOR_HH	src/generator.hh	/^#define PROTOCOLS_GENERATOR_HH$/;"	d
PROTOCOLS_MATRIX_HH	src/matrix.hh	/^#define PROTOCOLS_MATRIX_HH$/;"	d
PROTOCOLS_PROBABILITY_HH	src/probability.hh	/^#define PROTOCOLS_PROBABILITY_HH$/;"	d
PROTOCOLS_PROTOCOL_HH	src/protocol.hh	/^#define PROTOCOLS_PROTOCOL_HH$/;"	d
Podsumowanie	report/report.tex	/^\\subsection{Podsumowanie}$/;"	u	section:Analiza wyników i wydajność zaimplementowanych algorytmów
Podział pracy	report/report.tex	/^\\section{Podział pracy}$/;"	s
Prawidłowość implementacji	report/report.tex	/^\\subsection{Prawidłowość implementacji}$/;"	u	section:Implementacja i możliwość stosowania metod iteracyjnych
Probability	src/probability.cc	/^Probability::Probability (int agents_count, int cases_count)$/;"	f	class:Probability
Probability	src/probability.hh	/^Probability$/;"	c
Protocol	src/protocol.cc	/^Protocol::Protocol ()$/;"	f	class:Protocol
Protocol	src/protocol.cc	/^Protocol::Protocol (int yes_votes, int no_votes, int all_votes)$/;"	f	class:Protocol
Protocol	src/protocol.hh	/^Protocol {$/;"	c
Rys1a	report/report.tex	/^		\\caption{ \\label{Rys1a}}$/;"	l
Rys2a	report/report.tex	/^		\\caption{ \\label{Rys2a}}$/;"	l
Rys2b	report/report.tex	/^	\\caption{ \\label{Rys2b}}$/;"	l
Rys2c	report/report.tex	/^	\\caption{ \\label{Rys2c}}$/;"	l
Rys2d	report/report.tex	/^	\\caption{ \\label{Rys2d}}$/;"	l
Rys2e	report/report.tex	/^	\\caption{ \\label{Rys2e}}$/;"	l
SRCDIR	Makefile	/^SRCDIR=src$/;"	m
START_AGENT_COUNT	src/main.cc	/^#define  START_AGENT_COUNT /;"	d	file:
UNDECIDED	src/protocol.hh	/^  UNDECIDED \/\/ 2$/;"	e	enum:state
Util	src/util.cc	/^Util {$/;"	n	file:
Util	src/util.hh	/^namespace Util {$/;"	n
Wydajność	report/report.tex	/^\\subsection{Wydajność}$/;"	u	section:Analiza wyników i wydajność zaimplementowanych algorytmów
YES	src/protocol.hh	/^  YES,      \/\/ 1$/;"	e	enum:state
Zaimplementowane algorytmy	report/report.tex	/^\\subsection{Zaimplementowane algorytmy}$/;"	u	section:Operacje na macierzach
_GAUSS_UTIL_H	src/util.hh	/^#define _GAUSS_UTIL_H$/;"	d
abs_err	src/util.hh	/^  double abs_err     = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
abs_err_fg	src/util.hh	/^  double abs_err_fg  = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
abs_err_pg	src/util.hh	/^  double abs_err_pg  = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
agents_count	src/generator.hh	/^    int       agents_count;$/;"	m	class:Generator	typeref:typename:int
agents_count	src/probability.hh	/^    int agents_count;$/;"	m	class:Probability	typeref:typename:int
all	Makefile	/^all:$/;"	t
all	src/Makefile	/^all: probability.o matrix.o generator.o protocol.o util.o main.o$/;"	t
all_agents	src/protocol.hh	/^    int all_agents;$/;"	m	class:MonteCarlo	typeref:typename:int
all_votes	src/protocol.hh	/^    int all_votes;$/;"	m	class:Protocol	typeref:typename:int
avg_time	src/util.hh	/^  double avg_time    = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
avg_time_fg	src/util.hh	/^  double avg_time_fg = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
avg_time_pg	src/util.hh	/^  double avg_time_pg = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
backsub	src/matrix.hh	/^    *backsub (T **A, T *b, int *pivot)$/;"	f	class:MyMatrix	typeref:typename:T *
calculate_newton	src/util.cc	/^  calculate_newton (unsigned int n, unsigned int k)$/;"	f	namespace:Util	typeref:typename:unsigned int
case_mixed_agents	src/probability.cc	/^Probability::case_mixed_agents (Protocol protocol)$/;"	f	class:Probability	typeref:typename:double
case_one_undecided_agent	src/probability.cc	/^Probability::case_one_undecided_agent (Protocol protocol, int condition)$/;"	f	class:Probability	typeref:typename:double
case_undecided_agents	src/probability.cc	/^Probability::case_undecided_agents (Protocol protocol) {$/;"	f	class:Probability	typeref:typename:double
cases_count	src/generator.hh	/^    int       cases_count;$/;"	m	class:Generator	typeref:typename:int
cases_count	src/probability.hh	/^    int cases_count;$/;"	m	class:Probability	typeref:typename:int
change_state	src/protocol.cc	/^Agent::change_state (Agent &agent)$/;"	f	class:Agent	typeref:typename:void
clean	Makefile	/^clean:$/;"	t
clean	src/Makefile	/^clean:  rmobj$/;"	t
clone_matrix	src/matrix.hh	/^    **clone_matrix (T **matrix, int width)$/;"	f	class:MyMatrix	typeref:typename:T **
clone_vector	src/matrix.hh	/^    *clone_vector (T *vector, int width)$/;"	f	class:MyMatrix	typeref:typename:T *
count_abs_error	src/matrix.hh	/^    count_abs_error (T* exemplary, T* after_test, int width)$/;"	f	class:MyMatrix	typeref:typename:T
count_rel_error	src/matrix.hh	/^    count_rel_error (T* exemplary, T* after_test, int width)$/;"	f	class:MyMatrix	typeref:typename:T
cur_value	src/util.hh	/^  int cur_value = 0;$/;"	m	struct:progressbar_sync	typeref:typename:int
delete_matrix	src/matrix.hh	/^    delete_matrix (T **matrix, int width)$/;"	f	class:MyMatrix	typeref:typename:void
delete_vector	src/matrix.hh	/^    delete_vector (T *vector)$/;"	f	class:MyMatrix	typeref:typename:void
gaussian	src/matrix.hh	/^    *gaussian ()$/;"	f	class:MyMatrix	typeref:typename:T *
generate_probability_matrix	src/generator.cc	/^Generator::generate_probability_matrix () {$/;"	f	class:Generator	typeref:typename:void
generate_protocols_vector	src/generator.cc	/^Generator::generate_protocols_vector () {$/;"	f	class:Generator	typeref:typename:void
generate_value	src/probability.cc	/^Probability::generate_value (Protocol *protocols_vector, int row, int col)$/;"	f	class:Probability	typeref:typename:double
generator.o	src/Makefile	/^generator.o: generator.cc$/;"	t
get_agents_count	src/probability.cc	/^Probability::get_agents_count ()$/;"	f	class:Probability	typeref:typename:double
get_all_votes	src/protocol.cc	/^Protocol::get_all_votes ()$/;"	f	class:Protocol	typeref:typename:double
get_cases_count	src/probability.cc	/^Probability::get_cases_count ()$/;"	f	class:Probability	typeref:typename:double
get_matrix	src/matrix.hh	/^    **get_matrix ()$/;"	f	class:MyMatrix	typeref:typename:T **
get_no_votes	src/protocol.cc	/^Protocol::get_no_votes ()$/;"	f	class:Protocol	typeref:typename:double
get_undecided_votes	src/protocol.cc	/^Protocol::get_undecided_votes ()$/;"	f	class:Protocol	typeref:typename:double
get_vector_B	src/matrix.hh	/^    *get_vector_B ()$/;"	f	class:MyMatrix	typeref:typename:T *
get_vector_X	src/matrix.hh	/^    *get_vector_X ()$/;"	f	class:MyMatrix	typeref:typename:T *
get_width	src/matrix.hh	/^    get_width ()$/;"	f	class:MyMatrix	typeref:typename:int
get_yes_votes	src/protocol.cc	/^Protocol::get_yes_votes ()$/;"	f	class:Protocol	typeref:typename:double
iterations	src/protocol.hh	/^    int iterations;$/;"	m	class:MonteCarlo	typeref:typename:int
jacobi	src/matrix.hh	/^    *jacobi (int iterations)$/;"	f	class:MyMatrix	typeref:typename:T *
main	src/main.cc	/^int main (int argc, char *argv[])$/;"	f	typeref:typename:int
main.o	src/Makefile	/^main.o: main.cc$/;"	t
matrix	src/generator.hh	/^    double **matrix;$/;"	m	class:Generator	typeref:typename:double **
matrix	src/matrix.hh	/^    T **matrix;$/;"	m	class:MyMatrix	typeref:typename:T **
matrix.o	src/Makefile	/^matrix.o: matrix.cc$/;"	t
matrix_size	src/util.hh	/^  int matrix_size    = 0;$/;"	m	struct:result_fields	typeref:typename:int
matrix_vector	src/generator.hh	/^    double  *matrix_vector;$/;"	m	class:Generator	typeref:typename:double *
max_value	src/util.hh	/^  int max_value = 0;$/;"	m	struct:progressbar_sync	typeref:typename:int
no_votes	src/protocol.hh	/^    int no_votes;$/;"	m	class:Protocol	typeref:typename:int
print_help	src/util.cc	/^  print_help ()$/;"	f	namespace:Util	typeref:typename:void
print_matrix	src/matrix.hh	/^    print_matrix ()$/;"	f	class:MyMatrix	typeref:typename:void
print_progressbar	src/util.cc	/^  print_progressbar (int percentage)$/;"	f	namespace:Util	typeref:typename:void
probability.o	src/Makefile	/^probability.o: probability.cc$/;"	t
progressbar_sync	src/util.hh	/^typedef struct progressbar_sync {$/;"	s
progressbar_sync_t	src/util.hh	/^} progressbar_sync_t;$/;"	t	typeref:struct:progressbar_sync
protocol.o	src/Makefile	/^protocol.o: protocol.cc$/;"	t
protocols_equations	src/generator.hh	/^    double  **protocols_equations;$/;"	m	class:Generator	typeref:typename:double **
protocols_vector	src/generator.hh	/^    Protocol *protocols_vector;$/;"	m	class:Generator	typeref:typename:Protocol *
rel_err	src/util.hh	/^  double rel_err     = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
rel_err_fg	src/util.hh	/^  double rel_err_fg  = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
rel_err_pg	src/util.hh	/^  double rel_err_pg  = 0.0;$/;"	m	struct:result_fields	typeref:typename:double
result_fields	src/util.hh	/^typedef struct result_fields {$/;"	s
result_fields_t	src/util.hh	/^} result_fields_t;$/;"	t	typeref:struct:result_fields
rmobj	Makefile	/^rmobj:$/;"	t
rmobj	src/Makefile	/^rmobj:$/;"	t
rys	report/report.tex	/^	\\caption{Wykres reprezentujący błąd bezwzględny metod Gaussa oraz metod iteracyjnych wzglę/;"	l
rys	report/report.tex	/^	\\caption{Wykresy reprezentujące czas wykonania i błędy bezwzględne zaimplementowanych algo/;"	l
save_result_vec_to_file	src/util.cc	/^  save_result_vec_to_file (const vector<result_fields_t>&result_vec, string filename)$/;"	f	namespace:Util	typeref:typename:void
set_agents_count	src/probability.cc	/^Probability::set_agents_count (int agents_count)$/;"	f	class:Probability	typeref:typename:void
set_all_votes	src/protocol.cc	/^Protocol::set_all_votes (double all_votes)$/;"	f	class:Protocol	typeref:typename:void
set_cases_count	src/probability.cc	/^Probability::set_cases_count (int cases_count)$/;"	f	class:Probability	typeref:typename:void
set_matrix	src/matrix.hh	/^    void set_matrix (T **matrix)$/;"	f	class:MyMatrix	typeref:typename:void
set_no_votes	src/protocol.cc	/^Protocol::set_no_votes (double no_votes)$/;"	f	class:Protocol	typeref:typename:void
set_undecided_votes	src/protocol.cc	/^Protocol::set_undecided_votes (double undecided_votes)$/;"	f	class:Protocol	typeref:typename:void
set_vector_B	src/matrix.hh	/^    set_vector_B (T *vector)$/;"	f	class:MyMatrix	typeref:typename:void
set_vector_X	src/matrix.hh	/^    set_vector_X (T *vector)$/;"	f	class:MyMatrix	typeref:typename:void
set_yes_votes	src/protocol.cc	/^Protocol::set_yes_votes (double yes_votes)$/;"	f	class:Protocol	typeref:typename:void
state	src/protocol.hh	/^    state_t state;$/;"	m	class:Agent	typeref:typename:state_t
state	src/protocol.hh	/^typedef enum state {$/;"	g
state_t	src/protocol.hh	/^} state_t;$/;"	t	typeref:enum:state
undecided_votes	src/protocol.hh	/^    int undecided_votes;$/;"	m	class:Protocol	typeref:typename:int
util.o	src/Makefile	/^util.o: util.cc$/;"	t
vector_B	src/matrix.hh	/^    T  *vector_B;$/;"	m	class:MyMatrix	typeref:typename:T *
vector_X	src/matrix.hh	/^    T  *vector_X;$/;"	m	class:MyMatrix	typeref:typename:T *
width	src/matrix.hh	/^    int width;$/;"	m	class:MyMatrix	typeref:typename:int
wn:1	report/report.tex	/^	Metody iteracyjne umożliwiają rozwiązanie problemu aczkolwiek, by osiągnąć dokładniejsze/;"	l
yes_votes	src/protocol.hh	/^    int yes_votes;$/;"	m	class:Protocol	typeref:typename:int
~MyMatrix	src/matrix.hh	/^    ~MyMatrix ()$/;"	f	class:MyMatrix
